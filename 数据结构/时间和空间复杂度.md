---
title: 时间和空间复杂度
date: 2020-05-15 17:03:35
tags: 
	- Java
	- 面试
	- 基础
	- 数据结构
categories: 
	- 数据结构
---

算法，即解决问题的方法。同一个问题，使用不同的算法，虽然得到的结果相同，但是耗费的时间和资源是不同的。

# “好”算法的标准

对于一个问题的算法来说，之所以称之为算法，首先它必须能够解决这个问题（称为准确性）。其次，通过这个算法编写的程序要求在任何情况下不能崩溃（称为健壮性）。

如果准确性和健壮性都满足，接下来，就要考虑最重要的一点：通过算法编写的程序，运行的效率怎么样。

运行效率体现在两方面：

- 算法的运行时间。（称为“时间复杂度”）
- 运行算法所需的内存空间大小。（称为“空间复杂度”）

好算法的标准就是：在符合算法本身的要求的基础上，使用算法编写的程序运行的时间短，运行过程中占用的内存空间少，就可以称这个算法是“好算法”。

# 时间复杂度

由于是估算算法的时间复杂度，相比而言，循环结构对算法的执行时间影响更大。所以，算法的时间复杂度，主要看算法中使用到的循环结构中代码循环的次数**（称为“频度”）**。次数越少，算法的时间复杂度越低。
例如：

```
a) ++x; s=0;
b) for (int i=1; i<=n; i++) { ++x; s+=x; }
c) for (int i=1; i<=n; i++) { for (int j=1; i<=n; j++) { ++x; s+=x; } }
```

上边这个例子中，a 代码的运行了 1 次，b 代码的运行了 n 次，c 代码运行了 n*n 次。

**算法的时间复杂度的表示方式为：**

```
O(频度)
```

这种表示方式称为`大“O”记法`。

> 注意，是大写的字母`O`，不是数字`0`。

对于上边的例子而言，a 的时间复杂度为`O(1)`，b 的时间复杂度为`O(n)`，c 的时间复杂度为为`O(n2)`。

如果a、b、c组成一段程序，那么算法的时间复杂度为`O(n2+n+1)`。但这么表示是不对的，还需要对`n2+n+1`进行简化。

简化的过程总结为3步：

- 去掉运行时间中的所有加法常数。（例如 n²+n+1，直接变为 n²+n）
- 只保留最高项。（n²+n 变成 n²）
- 如果最高项存在但是系数不是1，去掉系数。（n² 系数为 1）

所以，最终a、b和c合并而成的代码的时间复杂度为`O(n²)`。

> 这里2时平方的意思

常见的时间复杂度量级有：

- 常数阶O(1)
- 对数阶O(logN)
- 线性阶O(n)
- 线性对数阶O(nlogN)
- 平方阶O(n²)
- 立方阶O(n³)
- K次方阶O(n^k)
- 指数阶(2^n)

上面从上至下依次的时间复杂度越来越大，执行的效率越来越低。

**常数阶O(1)**

无论代码执行了多少行，只要是没有循环等复杂结构，那这个代码的时间复杂度就都是O(1)，如：

```
int i = 1;
int j = 2;
++i;
j++;
int m = i + j;
```

**对数阶O(logN)**

```
int i = 1;
while(i<n)
{
    i = i * 2;
}
```

从上面代码可以看到，在while循环里面，每次都将 i 乘以 2，乘完之后，i 距离 n 就越来越近了。我们试着求解一下，假设循环x次之后，i 就大于 2 了，此时这个循环就退出了，也就是说 2 的 x 次方等于 n，那么 x = log2^n
也就是说当循环 log2^n 次以后，这个代码就结束了。因此这个代码的时间复杂度为：**O(logn)**

**线性阶O(n)**

```
for(i=1; i<=n; ++i)
{
   j = i;
   j++;
}
```

**线性对数阶O(nlogN)**

将时间复杂度为O(logn)的代码循环N遍的话，那么它的时间复杂度就是 n * O(logN)，也就是了O(nlogN)。

```
for(m=1; m<n; m++)
{
    i = 1;
    while(i<n)
    {
        i = i * 2;
    }
}
```

**平方阶O(n²)**

如果把 O(n) 的代码再嵌套循环一遍，它的时间复杂度就是 O(n²) 了。

```
for(x=1; i<=n; x++)
{
   for(i=1; i<=n; i++)
    {
       j = i;
       j++;
    }
}
```

这段代码其实就是嵌套了2层n循环，它的时间复杂度就是 O(n*n)，即 O(n²)

### 拿时间换空间，用空间换时间

算法的时间复杂度和空间复杂度是可以相互转化的。

谷歌浏览器相比于其他的浏览器，运行速度要快。是因为它占用了更多的内存空间，以空间换取了时间。

算法中，例如判断某个年份是否为闰年时，如果想以时间换取空间，算法思路就是：当给定一个年份时，判断该年份是否能被4或者400整除，如果可以，就是闰年。

如果想以空间换时间的话，判断闰年的思路就是：把所有的年份先判断出来，存储在数组中（年份和数组下标对应），如果是闰年，数组值是1，否则是0；当需要判断某年是否为闰年时，直接看对应的数组值是1还是0，不用计算就可以马上知道。

## 空间复杂度

一个程序的空间复杂度是指运行完一个程序所需内存的大小。利用程序的空间复杂度，可以对程序的运行所需要的内存多少有个预先估计。一个程序执行时除了需要存储空间和存储本身所使用的指令、常数、变量和输入数据外，还需要一些对数据进行操作的工作单元和存储一些为现实计算所需信息的辅助空间。

**空间复杂度可以理解为除了原始序列大小的内存，在算法过程中用到的额外的存储空间。**

